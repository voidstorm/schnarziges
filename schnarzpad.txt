
My Schnarzpad

-Add stream ops to tuple class stuff
-Make ThreadContext::request_exit queue a command an return a future instead. 


-https://content.pivotal.io/blog/all-evidence-points-to-oop-being-bullshit
https://medium.com/@cscalfani/goodbye-object-oriented-programming-a59cda4c0e53
http://wiki.c2.com/?ArgumentsAgainstOop
http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html

https://blogs.unity3d.com/2018/03/16/the-high-definition-render-pipeline-focused-on-visual-quality/

https://github.com/arximboldi/immer
https://www.youtube.com/watch?v=sPhpelUfu8Q

////-------------------------------------
/// Draft for game++ language-----------
////-----------------------------------

1.1 Scope of game++

The goal of game++ is to create a language framework for writing games. As such, the language should
provide direct support for game typical tasks, such as rendering, logic, resource management. The have
support on language level should help game developers to handle game specific tasks a lot easier. This includes
writing shaders and corresponding client code, game logic, network code, resource management and serialization.


1.2 Examples

opt
module MODULE_NAME::SUB_MODULE_NAME0...n{

    interface IF_NAME{
        interface SUB_IF_NAME{
            fun FN_NAME(param...) -> return_type : opt; 
        }
        fun FN_NAME(param...) -> return_type  : opt; 
    }


    class CLASS_NAME : INTERFACE0,...n{

        fun NAME(params..) -> return_type : opt{
            
        }
    }


    //Freestanding functions
    fun NAME(params..) -> return_type : opt{

        def a= 1.0f;
        //lambda
        def a_fun= fun(params)->rt{

        };

    //vector and matix types are part of the language

    vec2..4

    mat2..4

    mat2x4...mat4x4

    //universal init
    any_data_type = {};

    //tuple
   def a_tuple = (1,2,3);

    //array type
    def l = [1,2,4];
    def l2 = [1...23, 5...7, !6]; 1..23, then 5..7, remove all 6s

    def l2 = [1...100, !{x % 2}]; //only odd numbers

    def l2 = [2:100]; //fills with 2 x 100 times 

    def l2 = [type:100]; //fills with type x 100 times 

    def l2 = [1..100] |> map (fun(x){x % 2});


    //expressions
    def a= 1.0f;
    def a,b : float= 1.0f;
    def a,b : float= 1.0f, 2.0f;

 


    //lambda
    def a_fun= fun(params)->rt{

    };
 

    }


}



XI.) Completely new ideas

Node and task based. Input output nodes that operate on data. Organize language as task graph.


Node Example:


node SomeNode (input pins...) -> (output pins...){

}

node Add (int a, int b, bool status)-> (int result, bool status){
    result= a+b;
    status = true;
}



node Mult (int a, int b, bool status) -> (int result, bool status){
    result= a*b;
}

graph Main () -> (int result) {
    Add add(a= 1, b=2);
    Add add2(a= 1, b=2);

    Mult mult(a= add.result, b=add2.result, status= add.status);
    result= mult.result;
}


fun main(){

    Main main();

    def result= main.execAsync();    

}